///
/// @file Screen_EPD_EXT3.h
/// @brief Driver for Pervasive Displays iTC monochrome screens with embedded fast update and EXT3-1 board
///
/// @details Project Pervasive Displays Library Suite
/// @n Based on highView technology
///
/// @n @b A-SM-GF
/// * Edition: Advanced
/// * Family: Small, Medium
/// * Update: Global, Fast
/// * Feature: none
///
/// @n Supported screens with embedded fast update
/// * 1.54 reference xE2154PS0Cx
/// * 2.13 reference xE2213PS0Ex
/// * 2.66 reference xE2266PS0Cx
/// * 2.71 reference xE2271PS09x
/// * 2.87 reference xE2287PS09x
/// * 3.70 reference xE2370PS0Cx
/// * 4.17 reference xE2417PS0Dx
/// * 4.37 reference xE2437PS0Cx
///
/// @author Rei Vilo
/// @date 21 Aug 2023
/// @version 613
///
/// @copyright (c) Rei Vilo, 2010-2023
/// @copyright All rights reserved
///
/// * Evaluation edition: for professionals or organisations, no commercial usage
/// * Commercial edition: for professionals or organisations, commercial usage
///

// SDK
#include "hV_HAL_Peripherals.h"

// Configuration
#include "hV_Configuration.h"

#if (hV_CONFIGURATION_RELEASE < 611)
#error Required hV_CONFIGURATION_RELEASE 611
#endif // hV_CONFIGURATION_RELEASE

#if (hV_HAL_PERIPHERALS_RELEASE < 606)
#error Required hV_HAL_PERIPHERALS_RELEASE 606
#endif // hV_HAL_PERIPHERALS_RELEASE

#ifndef SCREEN_EPD_EXT3_RELEASE
///
/// @brief Library release number
///
#define SCREEN_EPD_EXT3_RELEASE 613

// Other libraries
#include "hV_Screen_Buffer.h"

#if (hV_SCREEN_BUFFER_RELEASE < 613)
#error Required hV_SCREEN_BUFFER_RELEASE 613
#endif // hV_SCREEN_BUFFER_RELEASE

#if (SRAM_MODE != USE_INTERNAL_MCU)
#warning SRAM_MODE should be USE_INTERNAL_MCU
#endif // SRAM_MODE

#if (SRAM_MODE == USE_EXTERNAL_SPI)
#include "hV_Memory.h"
#endif // SRAM_MODE

///
/// @brief Constant for file and serial access
///
#define WITH_FAST_FRIENDS

// Objects
//
///
/// @brief Class for Pervasive Displays iTC monochrome screens with embedded fast update
/// @details Screen controllers
/// * LCD: proprietary, SPI
/// * touch: no touch
/// * fonts: external Flash, SPI
///
/// @note All commands work on the frame-buffer,
/// to be displayed on screen with flush()
///
class Screen_EPD_EXT3_Fast final : public hV_Screen_Buffer
{
    friend class File_Header;
    friend class File_Image;
    friend class File_P4;

    friend class Serial_Image;
    friend class Serial_Image16;
    friend class Serial_P4;

  public:
    Screen_EPD_EXT3_Fast();

    /// @name Option 1: frame-buffer managed inside the class
    /// * Could be internal MCU or external SPI SRAM
    /// * Not suitable for FRAM
    /// * Not suitable for GUI
    ///
    /// @{

    /// @brief Constructor with default pins
    /// @param eScreen_EPD_EXT3 size and model of the e-screen
    /// @param board board configuration
    /// @note Frame-buffer generated by the class
    /// @note To be used with begin() with no parameter
    ///
    Screen_EPD_EXT3_Fast(eScreen_EPD_EXT3_t eScreen_EPD_EXT3, pins_t board);

    ///
    /// @brief Initialisation
    /// @note Frame-buffer generated internally, not suitable for FRAM
    /// @warning begin() initialises SPI and I2C
    ///
    void begin();

    /// @}

    /// @name Option 2: frame-buffer managed outside the class
    /// * Required for FRAM with PLACE_IN_FRAM
    /// * Required for PSRAM
    /// * Not suitable for external SPI
    /// * Highly recommended for GUI
    ///
    /// @{

#if (SRAM_MODE == USE_INTERNAL_MCU)

    ///
    /// @brief Constructor with default pins
    /// @param eScreen_EPD_EXT3 size and model of the e-screen
    /// @param board board configuration
    /// @param frameBuffer external frame-buffer
    /// @note Take the greatest frame-buffer size, with size and model of the e-screen changed later on at begin(eScreen_EPD_EXT3_t)
    /// @note External frame-buffer required for
    /// * FRAM on MSP430FR
    /// @code {.cpp}
    /// uint8_t * frameBuffer[frameSize_EPD_EXT3_271] PLACE_IN_FRAM;
    /// Screen_EPD_EXT3_Fast myScreen(eScreen_EPD_EXT3_271_09_Fast, boardLaunchPad, frameBuffer);
    /// @endcode
    /// * PSRAM on ESP32
    /// @code {.cpp}
    /// uint8_t * frameBuffer = (uint8_t *) ps_malloc(frameSize_EPD_EXT3_271);
    /// Screen_EPD_EXT3_Fast myScreen(eScreen_EPD_EXT3_271_09_Fast, boardESP32DevKitC, frameBuffer);
    /// @endcode
    ///
    Screen_EPD_EXT3_Fast(eScreen_EPD_EXT3_t eScreen_EPD_EXT3, pins_t board, uint8_t * frameBuffer); // = nullptr);

#endif // SRAM_MODE

    ///
    /// @brief Initialisation
    /// @param eScreen_EPD_EXT3 size and model of the e-screen
    /// @note Always smaller than size and model set at Screen_EPD_EXT3_Fast(eScreen_EPD_EXT3_t, unint8_t *)
    /// @note External frame-buffer required for FRAM and external SRAM
    /// @warning begin() initialises SPI and I2C
    ///
    void begin(eScreen_EPD_EXT3_t eScreen_EPD_EXT3);

    /// @}

    ///
    /// @brief Suspend
    /// @details Turn SPI off and set all GPIOs low
    ///
    void suspend();

    ///
    /// @brief Resume after suspend()
    /// @details Turn SPI on and set all GPIOs levels, reset panel and get tables
    ///
    void resume();

    ///
    /// @brief Who Am I
    /// @return Who Am I string
    ///
#if (STRING_MODE == USE_STRING_OBJECT)

    virtual String WhoAmI();

#elif (STRING_MODE == USE_CHAR_ARRAY)

    virtual char * WhoAmI();

#else

#error STRING_MODE

#endif // STRING_MODE

    ///
    /// @brief Clear the screen
    /// @param colour default = white
    /// @note Clear next frame-buffer
    ///
    void clear(uint16_t colour = myColours.white);

    ///
    /// @brief Invert screen
    /// @param flag true to invert, false for normal screen
    ///
    void invert(bool flag);

    ///
    /// @brief Update the display, global update
    /// @note Display next frame-buffer on screen and copy next frame-buffer into old frame-buffer
    ///
    void flush();

    ///
    /// @brief Update the display, fast update
    /// @note Display next frame-buffer on screen copy next frame-buffer into old frame-buffer
    ///
    void flushFast();

    ///
    /// @brief Regenerate the panel
    /// @details White-to-black-to-white cycle to reduce ghosting
    /// @param mode default = UPDATE_FAST = fast mode, otherwise UPDATE_GLOBAL = global mode
    /// @deprecated Partial update is deprecated. Use fast update instead (6.1.0).
    ///
    void regenerate(uint8_t mode = UPDATE_FAST);

    ///
    /// @brief Draw pixel
    /// @param x1 point coordinate, x-axis
    /// @param y1 point coordinate, y-axis
    /// @param colour 16-bit colour
    ///
    /// @n @b More: @ref Coordinate, @ref Colour
    ///
    void point(uint16_t x1, uint16_t y1, uint16_t colour);

    ///
    /// @brief Read pixel colour
    /// @param x1 point coordinate, x-axis
    /// @param y1 point coordinate, y-axis
    /// @return 16-bit colour, bits 15-11 red, bits 10-5 green, bits 4-0 blue
    ///
    /// @n @b More: @ref Coordinate, @ref Colour
    ///
    uint16_t readPixel(uint16_t x1, uint16_t y1);

    ///
    /// @brief Copy a source area to a target area
    /// @param x1 source top left coordinate, x-axis
    /// @param y1 source top left coordinate, y-axis
    /// @param x2 target top left coordinate, x-axis
    /// @param y2 target top left coordinate, y-axis
    /// @param dx width to be copied, x-axis
    /// @param dy height to be copied, y-axis
    /// @note This feature requires a readable screen.
    /// @warning The function does not manage the overlapping
    /// of the source and target areas.
    /// If such a case, use copyArea() pasteArea() instead.
    ///
    /// @n @b More: @ref Coordinate, @ref Screen
    ///
    void copyPasteArea(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t dx, uint16_t dy);

    ///
    /// @brief Get the pins of the board
    /// @return pins_t pins of the board
    ///
    pins_t getBoardPins();

    ///
    /// @brief Set temperature in Celsius
    /// @details Set the temperature for update
    /// @param temperatureC temperature in °C, default = 25 °C
    /// @note Refer to data-sheets for authorised operating temperatures
    ///
    void setTemperatureC(int8_t temperatureC = 25);

    ///
    /// @brief Set temperature in Fahrenheit
    /// @details Set the temperature for update
    /// @param temperatureF temperature in °F, default = 77 °F = 25 °C
    /// @note Refer to data-sheets for authorised operating temperatures
    ///
    void setTemperatureF(int16_t temperatureF = 77);

    ///
    /// @brief Check the mode against the temperature
    ///
    /// @param updateMode expected update mode
    /// @return uint8_t recommended mode
    /// @note If required, defaulting to UPDATE_GLOBAL or UPDATE_NONE
    /// @warning Default temperature is 25 °C, otherwise set by setTemperatureC() or setTemperatureF()
    ///
    uint8_t checkTemperatureMode(uint8_t updateMode);

    ///
    /// @brief Update the display
    /// @details Display next frame-buffer on screen and copy next frame-buffer into old frame-buffer
    /// @param updateMode expected update mode
    /// @return uint8_t recommended mode
    /// @note Mode checked with checkTemperatureMode()
    ///
    uint8_t flushMode(uint8_t updateMode);

    uint8_t ScreenBufferUpdated();

  protected:
    /// @cond

    ///
    /// @brief General reset
    /// @param ms1 delay after PNLON_PIN, ms
    /// @param ms2 delay after RESET_PIN HIGH, ms
    /// @param ms3 delay after RESET_PIN LOW, ms
    /// @param ms4 delay after RESET_PIN HIGH, ms
    /// @param ms5 delay after CS_PIN CSS_PIN HIGH, ms
    ///
    void _reset(uint32_t ms1, uint32_t ms2, uint32_t ms3, uint32_t ms4, uint32_t ms5);

    ///
    /// @brief Send fixed value through SPI
    /// @param index register
    /// @param data data, one byte covers 8 pixels
    /// @param len number of bytes
    /// @note Valid for all except large screens
    ///
    void _sendIndexFixed(uint8_t index, uint8_t data, uint32_t len);

    // * Virtual =0 compulsory functions
    // Screen-specific
    ///
    /// @brief Send data through SPI
    /// @param index register
    /// @param data data
    /// @param size number of bytes
    /// @note Valid for all except large screens
    ///
    void _sendIndexData(uint8_t index, const uint8_t * data, uint32_t size);

#if (SRAM_MODE == USE_EXTERNAL_SPI)
    ///
    /// @name Variants for SRAM
    /// @note data is an address instead of a pointer
    /// @note Valid for all screens except large screens
    ///
    void _sendIndexDataSRAM(uint8_t index, uint32_t data, uint32_t size); ///< Main
#endif // USE_EXTERNAL_SPI

    // Orientation
    ///
    /// @brief Set orientation
    /// @param orientation 1..3, 6, 7
    ///
    void _setOrientation(uint8_t orientation); // compulsory

    ///
    /// @brief Check and orient coordinates, logical coordinates
    /// @param x x-axis coordinate, modified
    /// @param y y-axis coordinate, modified
    /// @return false = success, true = error
    ///
    bool _orientCoordinates(uint16_t & x, uint16_t & y); // compulsory

    // Position

    // Write and Read
    /// @brief Set point
    /// @param x1 x coordinate
    /// @param y1 y coordinate
    /// @param colour 16-bit colour
    /// @n @b More: @ref Colour, @ref Coordinate
    ///
    void _setPoint(uint16_t x1, uint16_t y1, uint16_t colour);

    /// @brief Get point
    /// @param x1 x coordinate
    /// @param y1 y coordinate
    /// @return colour 16-bit colour
    /// @n @b More: @ref Colour, @ref Coordinate
    ///
    uint16_t _getPoint(uint16_t x1, uint16_t y1);

    ///
    /// @brief Convert
    /// @param x1 x-axis coordinate
    /// @param y1 y-axis coordinate
    /// @return index for _newImage[]
    ///
    uint32_t _getZ(uint16_t x1, uint16_t y1);

    ///
    /// @brief Wait for ready
    /// @details Wait for panelBusy low
    ///
    void _waitBusy();

    ///
    /// @brief Send a command
    /// @param command
    /// @note If needed, set panelCS HIGH manually after
    ///
    void _sendCommand8(uint8_t command);

    // Energy
    // No energy

    // * Other functions specific to the screen
    void COG_initial(uint8_t updateMode);
    void COG_getUserData();
    void COG_sendImageDataGlobal();
    void COG_sendImageDataFast();
    void COG_update(uint8_t updateMode);
    void COG_powerOff();

    // * Flush
    void _flushGlobal();
    void _flushFast();

    // Screen independent variables
#if (SRAM_MODE == USE_INTERNAL_MCU)

    uint8_t * _newImage;

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

    Memory myBufferSRAM;
    // Memory myBufferSRAM(MEMORY_SRAM, BUS_24_BITS);
    uint32_t _newImage;

#endif // SRAM_MODE

    bool _invert = false;
    // uint16_t _screenSizeV, _screenSizeH;
    int8_t _temperature = 25;

    // Screen dependent variables
    pins_t _pin;
    eScreen_EPD_EXT3_t _eScreen_EPD_EXT3;
    uint8_t _codeExtra;
    uint8_t _codeSize;
    uint8_t _codeType;
    uint16_t _bufferSizeV, _bufferSizeH, _bufferDepth;
    uint32_t _pageColourSize, _frameSize;
    // uint8_t _fsmPowerScreen;
    bool _flag50;

    // === Touch
    // No touch

    /// @endcond
};

#endif // SCREEN_EPD_EXT3_RELEASE

