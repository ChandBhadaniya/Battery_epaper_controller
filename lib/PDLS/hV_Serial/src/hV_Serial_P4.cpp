//
// hV_Serial_P4.cpp
// Library C++ code
// ----------------------------------
//
// Details Save screen content to BPM file on SD card
// Project Pervasive Displays Library Suite
//
// Created by Rei Vilo, 08 Jan 2021
//
// Copyright (c) Rei Vilo, 2010-2023
// Licence All rights reserved
//
// See hV_Serial_P4.h and ReadMe.txt for references
//
// Release 509: Renamed beginFileSystem endFileSystem
// Release 521: Added support for Linux
// Release 524: Added support for large screens
// Release 528: Added support for pixmap images
// Release 529: Added pixmap format
// Release 530: Added support for external SRAM
// Release 607: Added log messages
// Release 609: Deprecated partial update
// Release 610: Removed partial update
// Release 611: Added support for Teensy SD-card library
// Release 611: Added check on fast screens
//

// Library header
#include "hV_Serial_P4.h"

#if defined(WITH_FAST_FRIENDS)

Serial_P4::Serial_P4(Screen_EPD_EXT3_Fast * screen)
{
    _pScreen = screen;
}

void Serial_P4::readScreen(const uint8_t * imageP4)
{
    // image_s image;

    if ((imageP4[0] != 'P') or (imageP4[1] != '4'))
    {
        hV_HAL_log(LEVEL_DEBUG, "Header %c.%c", imageP4[0], imageP4[1]);
        hV_HAL_log(LEVEL_ERROR, "Not a P4 file");

        return;
    }

    uint8_t * c;
    c = (uint8_t *)imageP4 + 3; // should be 0x0a
    if (*c == '#') // if #, comment
    {
        while (*c != 0x0a) // look for next new line
        {
            c++;
        }
    }

    uint16_t minWindowH = 0;
    uint16_t minWindowV = 0;
    uint16_t maxWindowH = 0;
    uint16_t maxWindowV = 0;

    while (isdigit(*c))
    {
        maxWindowH *= 10;
        maxWindowH += (*c - '0');
        c++;
    }
    c++;
    while (isdigit(*c))
    {
        maxWindowV *= 10;
        maxWindowV += (*c - '0');
        c++;
    }
    c++;

    hV_HAL_log(LEVEL_INFO, "Read P4... Image H %i x V %i", maxWindowH, maxWindowV);

    if ((maxWindowH != _pScreen->_screenSizeH) or (maxWindowV != _pScreen->_screenSizeV))
    {
        hV_HAL_log(LEVEL_ERROR, "Size error... Screen H %i x V %i", _pScreen->_screenSizeH, _pScreen->_screenSizeV);

        return;
    }

#if (SRAM_MODE == USE_INTERNAL_MCU)

    memcpy(_pScreen->_newImage, c, _pScreen->_pageColourSize);

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

    _pScreen->myBufferSRAM.write(_pScreen->_newImage, c, _pScreen->_pageColourSize);

#endif // SRAM_MODE
}

// #if (STORAGE_MODE & USE_SERIAL_CONSOLE)

// === Serial P4
//
#if (STRING_MODE == USE_STRING_OBJECT)

void Serial_P4::saveScreen(String name)

#elif (STRING_MODE == USE_CHAR_ARRAY)

void Serial_P4::saveScreen(const char * name)

#endif
{
    if ((_pScreen->_codeSize == 0x96) or (_pScreen->_codeSize == 0xB9)) // Large screens
    {
        return;
    }

    char filePath[48] = {0};
#if (STRING_MODE == USE_STRING_OBJECT)

    String release = name.substring(0, 8) + "_RELEASE";
    release.toUpperCase();

#elif (STRING_MODE == USE_CHAR_ARRAY)

    char release[48] = {0};
    strcpy(release, "HEAD_PIXMAP_");
    strncat(release, name, 8);
    strcat(release, "_RELEASE");
    char * s = release;
    while (*s)
    {
        *s = toupper((unsigned char) * s);
        s++;
    }

#endif // STRING_MODE

    // uint32_t chrono = hV_HAL_getMilliseconds();

    // Start printing
    // hV_HAL_Serial_printf("// save... ");
    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Pixmap as header file generated by hV_Serial_P4");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // hV_HAL_Serial_printf("#if defined(ENERGIA) // LaunchPad specific");
    // hV_HAL_Serial_printf("#include \"Energia.h\"");
    // hV_HAL_Serial_printf("#else // Arduino general");
    // hV_HAL_Serial_printf("#include \"Arduino.h\"");
    // hV_HAL_Serial_printf("#endif // end IDE");

    hV_HAL_Serial_printf("// SDK");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#include \"hV_HAL_Peripherals.h\"");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Release");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#ifndef %s", release);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#define %s", release);
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("static const uint8_t Pixmap_");
    hV_HAL_Serial_printf(name);
    hV_HAL_Serial_printf("[] = ");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("{");
    hV_HAL_Serial_crlf();

    uint8_t p4FileHeader[3] = {'P', '4', 0x0a}; // P4 = magic number

    hV_HAL_Serial_printf("    ");
    for (uint8_t index = 0; index < 3; index++)
    {
        hV_HAL_Serial_printf("0x%02x, ", p4FileHeader[index]);
    }
    hV_HAL_Serial_printf("// P4 header");
    hV_HAL_Serial_crlf();

    char p4InformationHeader[16] = {0}; // size H V \n
    strcpy(p4InformationHeader, formatString("%i %i\n\0", _pScreen->_screenSizeH, _pScreen->_screenSizeV));

    hV_HAL_Serial_printf("    ");
    for (uint8_t index = 0; index < strlen(p4InformationHeader); index++)
    {
        hV_HAL_Serial_printf("0x%02x, ", p4InformationHeader[index]);
    }
    hV_HAL_Serial_printf("// H x V = %i %i", _pScreen->_screenSizeH, _pScreen->_screenSizeV);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    // size= %i", _pScreen->_pageColourSize);
    hV_HAL_Serial_crlf();

    for (uint32_t index = 0; index < _pScreen->_pageColourSize; index++)
    {
        if ((index % (_pScreen->_screenSizeH / 8)) == 0)
        {
            hV_HAL_Serial_printf("    "); // leading spaces
        }

#if (SRAM_MODE == USE_INTERNAL_MCU)

        hV_HAL_Serial_printf("0x%02x, ", _pScreen->_newImage[index]);

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

        hV_HAL_Serial_printf("0x%02x, ", _pScreen->myBufferSRAM.get(index));

#endif // SRAM_MODE
        if (((index + 1) % (_pScreen->_screenSizeH / 8)) == 0)
        {
            hV_HAL_Serial_printf("// v= %i", index / (_pScreen->_screenSizeH / 8)); // line number
            hV_HAL_Serial_crlf();
        }
    }

    hV_HAL_Serial_printf("};");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // Stop printing
    hV_HAL_Serial_printf("#endif // %s", release);
    hV_HAL_Serial_crlf();

    // hV_HAL_Serial_printf("// ...");
    // hV_HAL_Serial_printf("%i", hV_HAL_getMilliseconds() - chrono);
    // hV_HAL_Serial_printf(" ms");
}

// #endif // STORAGE_MODE

#endif // WITH_FAST_FRIENDS

