//
// hV_Serial_Image16.cpp
// Library C++ code
// ----------------------------------
//
// Details Save screen content to BPM file on SD card
// Project Pervasive Displays Library Suite
//
// Created by Rei Vilo, 08 Jan 2021
//
// Copyright (c) Rei Vilo, 2010-2023
// Licence All rights reserved
//
// See hV_Serial_Image16.h and ReadMe.txt for references
//
// Release 509: Renamed beginFileSystem endFileSystem
// Release 521: Added support for Linux
// Release 524: Added support for large screens
// Release 528: Added support for pixmap images
// Release 529: Added pixmap format
// Release 530: Added support for external SRAM
// Release 607: Added log messages
// Release 609: Deprecated partial update
// Release 610: Removed partial update
// Release 611: Added check on fast screens
// Release 612: Improved stability for Image16
//

// Library header
#include "hV_Serial_Image16.h"

// Serial_Image16::Serial_Image16(Screen_EPD_EXT3_Fast * screen)
Serial_Image16::Serial_Image16(hV_Screen_Virtual * screen)
{
    _pScreen = screen;
}

// #if (STORAGE_MODE & USE_SERIAL_CONSOLE)

// === Serial
//
#if (STRING_MODE == USE_STRING_OBJECT)

void Serial_Image16::saveScreen(String name)

#elif (STRING_MODE == USE_CHAR_ARRAY)

void Serial_Image16::saveScreen(const char * name)

#endif // STRING_MODE
{
    saveWindow(name, 0, 0, _pScreen->screenSizeX(), _pScreen->screenSizeY());
}

#if (STRING_MODE == USE_STRING_OBJECT)

void Serial_Image16::saveWindow(String name, uint16_t x0, uint16_t  y0, uint16_t dx, uint16_t dy)

#elif (STRING_MODE == USE_CHAR_ARRAY)

void Serial_Image16::saveWindow(const char * name, uint16_t x0, uint16_t  y0, uint16_t dx, uint16_t dy)

#endif // STRING_MODE
{
    char filePath[48] = {0};

#if (STRING_MODE == USE_STRING_OBJECT)

    String release = name.substring(0, 8) + "_RELEASE";
    release.toUpperCase();

#elif (STRING_MODE == USE_CHAR_ARRAY)

    char release[48] = {0};
    strcpy(release, "HEAD_IMAGE16_");
    strncat(release, name, 8);
    strcat(release, "_RELEASE");
    char * s = release;
    while (*s)
    {
        *s = toupper((unsigned char) * s);
        s++;
    }

#endif // STRING_MODE

    // uint32_t chrono = hV_HAL_getMilliseconds();
    uint16_t x, y;

    uint16_t w = dx; // image width in pixels
    uint16_t h = dy; // image height

    // Start printing
    // hV_HAL_Serial_printf("// save... ");
    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Image16 as header file generated by hV_Serial_Image16");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // hV_HAL_Serial_printf("#if defined(ENERGIA) // LaunchPad specific");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#include \"Energia.h\"");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#else // Arduino general");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#include \"Arduino.h\"");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#endif // end IDE");
    // hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("// SDK");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#include \"hV_HAL_Peripherals.h\"");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Release");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#ifndef %s", release);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#define %s", release);
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("#include \"hV_Image16.h\"");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("static const uint16_t Table_");
    hV_HAL_Serial_printf(name);
    hV_HAL_Serial_printf("[] = ");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("{");
    // hV_HAL_Serial_crlf();

    uint32_t fileSize = 0; // (uint32_t)(screenSizeX() * screenSizeY() / 8);
    uint32_t zOffset;

    uint16_t valueRGB;
    uint8_t valueHigh, valueLow;
    for (uint16_t i = h; i > 0; i--)
    {
        // for (uint16_t k = 0; k < multiplier; k++)
        // {
        hV_HAL_Serial_crlf();
        hV_HAL_Serial_printf("    ");

        for (uint16_t j = 0; j < w; j++)
        {
            valueRGB = _pScreen->readPixel(x0 + j, y0 + i - 1);

            hV_HAL_Serial_printf("0x%04x, ", valueRGB);
            fileSize += 1;
            // }
        }
        hV_HAL_Serial_printf("// v= %i", y0 + i);
    }

    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("};");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("const image16_s Image16_%s =", name);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("{");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .minWindowH = %i,", x0); // Rectangular coordinates
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .minWindowV = %i,", y0); // Rectangular coordinates
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .maxWindowH = %i,", x0 + dx - 1); // Rectangular coordinates
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .maxWindowV = %i,", y0 + dy - 1); // Rectangular coordinates
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .depth = %i,", _pScreen->screenColourBits());
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .size = %i,", fileSize);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .table = Table_");
    hV_HAL_Serial_printf(name);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("};");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // Stop printing
    hV_HAL_Serial_printf("#endif // %s", release);
    hV_HAL_Serial_crlf();

    // hV_HAL_Serial_printf("// ...");
    // hV_HAL_Serial_printf("%i ms", hV_HAL_getMilliseconds() - chrono);
    // hV_HAL_Serial_crlf();
}

void Serial_Image16::readScreen(image16_s image)
{
    uint16_t valueRGB;
    uint16_t dH = image.maxWindowH - image.minWindowH + 1;
    uint16_t dV = image.maxWindowV - image.minWindowV;

    for (uint16_t i = image.minWindowV; i < image.maxWindowV; i++)
    {
        for (uint16_t j = image.minWindowH; j < image.maxWindowH; j++)
        {
            uint32_t k = j + (dV - i) * dH;
            valueRGB = image.table[k];

            _pScreen->point(j, i, valueRGB);
        }
    }
}

// #endif // STORAGE_MODE

