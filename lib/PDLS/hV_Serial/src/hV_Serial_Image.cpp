//
// hV_Serial_Image.cpp
// Library C++ code
// ----------------------------------
//
// Details Save screen content to BPM file on SD card
// Project Pervasive Displays Library Suite
//
// Created by Rei Vilo, 08 Jan 2021
//
// Copyright (c) Rei Vilo, 2010-2023
// Licence All rights reserved
//
// See hV_Serial_Image.h and ReadMe.txt for references
//
// Release 509: Renamed beginFileSystem endFileSystem
// Release 521: Added support for Linux
// Release 524: Added support for large screens
// Release 528: Added support for pixmap images
// Release 529: Added pixmap format
// Release 530: Added support for external SRAM
// Release 607: Added log messages
// Release 609: Deprecated partial update
// Release 610: Removed partial update
// Release 611: Added support for Teensy SD-card library
// Release 611: Added check on fast screens
// Release 612: Improved stability for Image16
//

// Library header
#include "hV_Serial_Image.h"

#if defined(WITH_FAST_FRIENDS)

Serial_Image::Serial_Image(Screen_EPD_EXT3_Fast * screen)
{
    _pScreen = screen;
}

// #if (STORAGE_MODE & USE_SERIAL_CONSOLE)

// === Serial
//
#if (STRING_MODE == USE_STRING_OBJECT)

void Serial_Image::saveScreen(String name)

#elif (STRING_MODE == USE_CHAR_ARRAY)

void Serial_Image::saveScreen(const char * name)

#endif // STRING_MODE
{
    saveWindow(name, 0, 0, _pScreen->screenSizeX(), _pScreen->screenSizeY());
}

#if (STRING_MODE == USE_STRING_OBJECT)

void Serial_Image::saveWindow(String name, uint16_t x0, uint16_t  y0, uint16_t dx, uint16_t dy)

#elif (STRING_MODE == USE_CHAR_ARRAY)

void Serial_Image::saveWindow(const char * name, uint16_t x0, uint16_t  y0, uint16_t dx, uint16_t dy)

#endif // STRING_MODE
{
    char filePath[48] = {0};

#if (STRING_MODE == USE_STRING_OBJECT)

    String release = name.substring(0, 8) + "_RELEASE";
    release.toUpperCase();

#elif (STRING_MODE == USE_CHAR_ARRAY)

    char release[48] = {0};
    strcpy(release, "HEAD_IMAGE_");
    strncat(release, name, 8);
    strcat(release, "_RELEASE");
    char * s = release;
    while (*s)
    {
        *s = toupper((unsigned char) * s);
        s++;
    }

#endif // STRING_MODE

    // uint32_t chrono = hV_HAL_getMilliseconds();
    uint16_t x, y;

    uint16_t _minWindowV = _pScreen->_screenSizeV + _pScreen->_screenSizeH;
    uint16_t _minWindowH = _pScreen->_screenSizeV + _pScreen->_screenSizeH;
    uint16_t _maxWindowV = 0;
    uint16_t _maxWindowH = 0;

    x = x0;
    y = y0;
    _pScreen->_orientCoordinates(x, y);
    setMinMax(x, _minWindowV, _maxWindowV);
    setMinMax(y, _minWindowH, _maxWindowH);

    x = x0 + dx - 1;
    y = y0;
    _pScreen->_orientCoordinates(x, y);
    setMinMax(x, _minWindowV, _maxWindowV);
    setMinMax(y, _minWindowH, _maxWindowH);

    x = x0;
    y = y0 + dy - 1;
    _pScreen->_orientCoordinates(x, y);
    setMinMax(x, _minWindowV, _maxWindowV);
    setMinMax(y, _minWindowH, _maxWindowH);

    x = x0 + dx - 1;
    y = y0 + dy - 1;
    _pScreen->_orientCoordinates(x, y);
    setMinMax(x, _minWindowV, _maxWindowV);
    setMinMax(y, _minWindowH, _maxWindowH);

    // Horizontal: 8 pixels per byte
    _minWindowH = _minWindowH & ~0x0007;
    _maxWindowH = _maxWindowH | 0x0007;

    // // Vertical: 1 pixel per line, not correction required
    // _minWindowV = _minWindowV & ~0x0007;
    // _maxWindowV = _maxWindowV | 0x0007;

    uint16_t zBase = _pScreen->_getZ(_minWindowV, _minWindowH);
    uint16_t zdH = _pScreen->_getZ(_minWindowV, _maxWindowH) - zBase + 1;
    uint16_t zdV = _pScreen->_getZ(_maxWindowV, _minWindowH) - zBase + 1;
    zdV /= _pScreen->_bufferSizeH;
    zdV += 1;

    // Start printing
    // hV_HAL_Serial_printf("// save... ");
    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Image as header file generated by hV_Serial_Image");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // hV_HAL_Serial_printf("#if defined(ENERGIA) // LaunchPad specific");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#include \"Energia.h\"");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#else // Arduino general");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#include \"Arduino.h\"");
    // hV_HAL_Serial_crlf();
    // hV_HAL_Serial_printf("#endif // end IDE");
    // hV_HAL_Serial_crlf();

    hV_HAL_Serial_printf("// SDK");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#include \"hV_HAL_Peripherals.h\"");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("// Release");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#ifndef %s", release);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("#define %s", release);
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("#include \"hV_Image.h\"");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("static const uint8_t Table_");
    hV_HAL_Serial_printf(name);
    hV_HAL_Serial_printf("[] = ");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("{");
    // hV_HAL_Serial_crlf();

    uint32_t fileSize = 0; // (uint32_t)(screenSizeX() * screenSizeY() / 8);
    uint32_t zOffset;

    if ((_pScreen->_codeSize == 0x96) or (_pScreen->_codeSize == 0xB9)) // Large screens
    {
        for (uint32_t zV = _minWindowV; zV < _maxWindowV + 1; zV++)
        {
            hV_HAL_Serial_crlf();
            hV_HAL_Serial_printf("    ");

            for (uint32_t zH = _minWindowH; zH < _maxWindowH; zH += 8)
            {
                fileSize++;

#if (SRAM_MODE == USE_INTERNAL_MCU)

                hV_HAL_Serial_printf("0x%02x, ", _pScreen->_newImage[_pScreen->_getZ(zV, zH)]);

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

                hV_HAL_Serial_printf("0x%02x, ", _pScreen->myBufferSRAM.get(_pScreen->_getZ(zV, zH)));

#endif // SRAM_MODE
            }
            hV_HAL_Serial_printf(" // v= %i", _minWindowV + zV);
        }
    }
    else // All other screens
    {
        for (uint32_t zV = 0; zV < zdV; zV++)
        {
            hV_HAL_Serial_crlf();
            hV_HAL_Serial_printf("    ");

            zOffset = zBase + zV * _pScreen->_bufferSizeH;
            for (uint32_t zH = 0; zH < zdH; zH++)
            {
                fileSize++;

#if (SRAM_MODE == USE_INTERNAL_MCU)

                hV_HAL_Serial_printf("0x%02x, ", _pScreen->_newImage[zOffset + zH]);

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

                hV_HAL_Serial_printf("0x%02x, ", _pScreen->myBufferSRAM.get(zOffset + zH));

#endif // SRAM_MODE
            }
            hV_HAL_Serial_printf("// v= %i", _minWindowV + zV);
        }
    } // _pScreen->_codeSize

    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("};");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    hV_HAL_Serial_printf("const image_s Image_%s =", name);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("{");
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .minWindowH = %i,", _minWindowH);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .minWindowV = %i,", _minWindowV);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .maxWindowH = %i,", _maxWindowH);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .maxWindowV = %i,", _maxWindowV);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .depth = %i,", _pScreen->screenColourBits());
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .size = %i,", fileSize);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("    .table = Table_");
    hV_HAL_Serial_printf(name);
    hV_HAL_Serial_crlf();
    hV_HAL_Serial_printf("};");
    hV_HAL_Serial_crlf();

    hV_HAL_Serial_crlf(); // Section

    // Stop printing
    hV_HAL_Serial_printf("#endif // %s", release);
    hV_HAL_Serial_crlf();

    // hV_HAL_Serial_printf("// ...");
    // hV_HAL_Serial_printf("%i", hV_HAL_getMilliseconds() - chrono);
    // hV_HAL_Serial_printf(" ms");
}

// #endif // STORAGE_MODE

void Serial_Image::readScreen(image_s image)
{
    if ((_pScreen->_codeSize == 0x96) or (_pScreen->_codeSize == 0xB9)) // Large screens
    {
        uint32_t index = 0;

        // Load image into frame-buffer
        for (uint32_t zV = image.minWindowV; zV < image.maxWindowV + 1; zV++)
        {
            // zOffset = zBase + zV * image.bufferSizeH;
            for (uint32_t zH = image.minWindowH; zH < image.maxWindowH; zH += 8)
            {

#if (SRAM_MODE == USE_INTERNAL_MCU)

                _pScreen->_newImage[_pScreen->_getZ(zV, zH)] = image.table[index];

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

                _pScreen->myBufferSRAM.set(_pScreen->_getZ(zV, zH), image.table[index]);

#endif // SRAM_MODE

                index++;
            }
        }
    }
    else // All other screens
    {
        uint16_t zBase = _pScreen->_getZ(image.minWindowV, image.minWindowH);
        uint16_t zdH = _pScreen->_getZ(image.minWindowV, image.maxWindowH) - zBase + 1;
        uint16_t zdV = _pScreen->_getZ(image.maxWindowV, image.minWindowH) - zBase + 1;
        zdV /= _pScreen->_bufferSizeH;
        zdV += 1;

        // Load image into frame-buffer
        uint32_t index = 0;
        uint32_t zOffset;

        for (uint32_t zV = 0; zV < zdV; zV++)
        {
            zOffset = zBase + zV * _pScreen->_bufferSizeH;

#if (SRAM_MODE == USE_INTERNAL_MCU)

            memcpy(_pScreen->_newImage + zOffset, image.table + index, zdH);

#elif (SRAM_MODE == USE_EXTERNAL_SPI)

            _pScreen->myBufferSRAM.write(_pScreen->_newImage + zOffset, image.table + index, zdH);

#endif // SRAM_MODE

            index += zdH;
        }
    } // _pScreen->_codeSize
}

#endif // WITH_FAST_FRIENDS

